package com.javadude.annotation.processors;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Date;

import org.junit.Assert;
import org.junit.Test;

import com.javadude.annotation.PropertyKind;

@SuppressWarnings("deprecation")
public class GeneratorTest {
	@Test public void test0010() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(false);
		data.setEqualsShouldCheckSuperEquals(false);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0020() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(false);
		data.setEqualsShouldCheckSuperEquals(false);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"abstract class FooGen {\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0030() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(true);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(false);
		data.setEqualsShouldCheckSuperEquals(false);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen implements Cloneable {\r\n" +
				"	@Override\r\n" +
				"	public Foo clone() {\r\n" +
				"		try {\r\n" +
				"			return (Foo) super.clone();\r\n" +
				"		} catch (CloneNotSupportedException e) {\r\n" +
				"			// will not happen\r\n" +
				"			return null;\r\n" +
				"		}\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0040() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(false);
		data.setEqualsShouldCheckSuperEquals(false);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass("x.y.z.Super1");
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen extends x.y.z.Super1 {\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0050() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(true);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(false);
		data.setEqualsShouldCheckSuperEquals(false);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass("x.y.z.Super1");
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen extends x.y.z.Super1 implements Cloneable {\r\n" +
				"	@Override\r\n" +
				"	public Foo clone() {\r\n" +
				"		try {\r\n" +
				"			return (Foo) super.clone();\r\n" +
				"		} catch (CloneNotSupportedException e) {\r\n" +
				"			// will not happen\r\n" +
				"			return null;\r\n" +
				"		}\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0060() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(false);
		data.setEqualsShouldCheckSuperEquals(false);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass("x.y.z.Super1");
		data.setSuperConstructorArgs("int x, String y");
		data.setSuperConstructorSuperCall("super(x, y)");
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen extends x.y.z.Super1 {\r\n" +
				"	public FooGen(int x, String y) {\r\n" +
				"		super(x, y);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0070() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(false);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass()) return false;\r\n" +
				"		return true;\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0080() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		return true;\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return \"\";\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	// start testing properties
	@Test public void test0090() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(false);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.SIMPLE);
		propertySpec.setName("name");
		propertySpec.setNotNull(false);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName(null);
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.lang.String name_;\r\n" +
				"	public java.lang.String getName() {\r\n" +
				"		return name_;\r\n" +
				"	}\r\n" +
				"	public void setName(java.lang.String value) {\r\n" +
				"		name_ = value;\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.name_, name_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			name_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"name=\" + name_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0100() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.SIMPLE);
		propertySpec.setName("name");
		propertySpec.setNotNull(false);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName(null);
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private java.lang.String name_;\r\n" +
				"	public java.lang.String getName() {\r\n" +
				"		return name_;\r\n" +
				"	}\r\n" +
				"	public void setName(java.lang.String value) {\r\n" +
				"		java.lang.String oldValue = name_;\r\n" +
				"		name_ = value;\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"name\", oldValue, value);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.name_, name_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			name_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"name=\" + name_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0110() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.SIMPLE);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(true);
		propertySpec.setPluralName(null);
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private java.lang.String name_;\r\n" +
				"	public java.lang.String getName() {\r\n" +
				"		return name_;\r\n" +
				"	}\r\n" +
				"	public void setName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"name cannot be null\");\r\n" +
				"		java.lang.String oldValue = name_;\r\n" +
				"		name_ = value;\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"name\", oldValue, value);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.name_, name_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			name_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"name=\" + '<' + name_.getClass().getName() + '>';\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0120() {
		Data data = new Data();
		data.setAtLeastOneBound(false);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(false);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.LIST);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName("names");
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private final java.util.List<java.lang.String> names_ = new java.util.ArrayList<java.lang.String>();\r\n" +
				"	public java.lang.String getName(int i) {\r\n" +
				"		return names_.get(i);\r\n" +
				"	}\r\n" +
				"	public java.util.List<java.lang.String> getNames() {\r\n" +
				"		return names_;\r\n" +
				"	}\r\n" +
				"	public java.lang.String removeName(int i) {\r\n" +
				"		java.lang.String result = names_.remove(i);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void addName(int i, java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(i, value);\r\n" +
				"	}\r\n" +
				"	public boolean namesContains(java.lang.String value) {\r\n" +
				"		return names_.contains(value);\r\n" +
				"	}\r\n" +
				"	public void addName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(value);\r\n" +
				"	}\r\n" +
				"	public boolean removeName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot remove null from name\");\r\n" +
				"		boolean result = names_.remove(value);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void clearNames() {\r\n" +
				"		names_.clear();\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.names_, names_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			names_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"names=\" + names_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0130() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.LIST);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName("names");
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private final java.util.List<java.lang.String> names_ = new java.util.ArrayList<java.lang.String>();\r\n" +
				"	public java.lang.String getName(int i) {\r\n" +
				"		return names_.get(i);\r\n" +
				"	}\r\n" +
				"	public java.util.List<java.lang.String> getNames() {\r\n" +
				"		return names_;\r\n" +
				"	}\r\n" +
				"	public java.lang.String removeName(int i) {\r\n" +
				"		java.lang.String result = names_.remove(i);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void addName(int i, java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(i, value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public boolean namesContains(java.lang.String value) {\r\n" +
				"		return names_.contains(value);\r\n" +
				"	}\r\n" +
				"	public void addName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public boolean removeName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot remove null from name\");\r\n" +
				"		boolean result = names_.remove(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void clearNames() {\r\n" +
				"		names_.clear();\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.names_, names_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			names_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"names=\" + names_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0140() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.UNMODIFIABLE_LIST);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName("names");
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private final java.util.List<java.lang.String> names_ = new java.util.ArrayList<java.lang.String>();\r\n" +
				"	public java.lang.String getName(int i) {\r\n" +
				"		return names_.get(i);\r\n" +
				"	}\r\n" +
				"	public java.util.List<java.lang.String> getNames() {\r\n" +
				"		return Collections.unmodifiableList(names_);\r\n" +
				"	}\r\n" +
				"	public java.lang.String removeName(int i) {\r\n" +
				"		java.lang.String result = names_.remove(i);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void addName(int i, java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(i, value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public boolean namesContains(java.lang.String value) {\r\n" +
				"		return names_.contains(value);\r\n" +
				"	}\r\n" +
				"	public void addName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public boolean removeName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot remove null from name\");\r\n" +
				"		boolean result = names_.remove(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void clearNames() {\r\n" +
				"		names_.clear();\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.names_, names_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			names_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"names=\" + names_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0150() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.UNMODIFIABLE_SET);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName("names");
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private final java.util.Set<java.lang.String> names_ = new java.util.HashSet<java.lang.String>();\r\n" +
				"	public java.util.Set<java.lang.String> getNames() {\r\n" +
				"		return Collections.unmodifiableList(names_);\r\n" +
				"	}\r\n" +
				"	public boolean namesContains(java.lang.String value) {\r\n" +
				"		return names_.contains(value);\r\n" +
				"	}\r\n" +
				"	public void addName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public boolean removeName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot remove null from name\");\r\n" +
				"		boolean result = names_.remove(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void clearNames() {\r\n" +
				"		names_.clear();\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.names_, names_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			names_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"names=\" + names_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0160() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType(null);
		propertySpec.setKind(PropertyKind.SET);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName("names");
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private final java.util.Set<java.lang.String> names_ = new java.util.HashSet<java.lang.String>();\r\n" +
				"	public java.util.Set<java.lang.String> getNames() {\r\n" +
				"		return names_;\r\n" +
				"	}\r\n" +
				"	public boolean namesContains(java.lang.String value) {\r\n" +
				"		return names_.contains(value);\r\n" +
				"	}\r\n" +
				"	public void addName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to name\");\r\n" +
				"		names_.add(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public boolean removeName(java.lang.String value) {\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot remove null from name\");\r\n" +
				"		boolean result = names_.remove(value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void clearNames() {\r\n" +
				"		names_.clear();\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.names_, names_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			names_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"names=\" + names_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0170() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType("java.lang.Integer");
		propertySpec.setKind(PropertyKind.MAP);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName("names");
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private final java.util.Map<java.lang.Integer, java.lang.String> names_ = new java.util.HashMap<java.lang.Integer, java.lang.String>();\r\n" +
				"	public java.lang.String getName(java.lang.Integer key) {\r\n" +
				"		return names_.get(key);\r\n" +
				"	}\r\n" +
				"	public java.util.Map<java.lang.Integer, java.lang.String> getNames() {\r\n" +
				"		return names_;\r\n" +
				"	}\r\n" +
				"	public boolean namesContainsKey(java.lang.Integer key) {\r\n" +
				"		return names_.containsKey(key);\r\n" +
				"	}\r\n" +
				"	public boolean namesContainsValue(java.lang.String value) {\r\n" +
				"		return names_.containsValue(value);\r\n" +
				"	}\r\n" +
				"	public void putName(java.lang.Integer key, java.lang.String value) {\r\n" +
				"		if (key == null) throw new IllegalArgumentException(\"Cannot put null key in name\");\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot put null value in name\");\r\n" +
				"		names_.put(key, value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public java.lang.String removeName(java.lang.Integer key) {\r\n" +
				"		if (key == null) throw new IllegalArgumentException(\"Cannot remove null key from name\");\r\n" +
				"		java.lang.String result = names_.remove(key);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void clearNames() {\r\n" +
				"		names_.clear();\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.names_, names_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			names_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"names=\" + names_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
	@Test public void test0180() {
		Data data = new Data();
		data.setAtLeastOneBound(true);
		data.setClassAccess("public ");
		data.setClassName("Foo");
		data.setCloneable(false);
		data.setCreatePropertyMap(false);
		data.setDate(new Date(108, 9, 4));
		data.setDefineSimpleEqualsAndHashCode(true);
		data.setEqualsShouldCheckSuperEquals(true);
		data.setPackageName("a.b.c");
		data.setSpacesForLeadingTabs(0);
		data.setSuperclass(null);
		data.setSuperConstructorArgs("");
		data.setSuperConstructorSuperCall(null);
		data.setYear(2008);

		PropertySpec propertySpec = new PropertySpec();
		propertySpec.setBound(true);
		propertySpec.setExtraFieldKeywords("");
		propertySpec.setExtraMethodKeywords("");
		propertySpec.setKeyType("java.lang.Integer");
		propertySpec.setKind(PropertyKind.UNMODIFIABLE_MAP);
		propertySpec.setName("name");
		propertySpec.setNotNull(true);
		propertySpec.setOmitFromToString(false);
		propertySpec.setPluralName("names");
		propertySpec.setPrimitive(false);
		propertySpec.setReadable(true);
		propertySpec.setReaderAccess("public ");
		propertySpec.setType("java.lang.String");
		propertySpec.setWriteable(true);
		propertySpec.setWriterAccess("public ");

		data.addProperty(propertySpec);

		StringWriter sw = new StringWriter();
		PrintWriter pw = new PrintWriter(sw);
		new Generator(pw, data).generate();
		Assert.assertEquals(
				"// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR\r\n" +
				"// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --\r\n" +
				"package a.b.c;\r\n" +
				"@javax.annotation.Generated(\r\n" +
				"	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",\r\n" +
				"	date = \"Sat Oct 04 00:00:00 EDT 2008\",\r\n" +
				"	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")\r\n" +
				"public abstract class FooGen {\r\n" +
				"	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);\r\n" +
				"	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {\r\n" +
				"		return propertyChangeSupport_;\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(listener);\r\n" +
				"	}\r\n" +
				"	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {\r\n" +
				"		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);\r\n" +
				"	}\r\n" +
				"	private final java.util.Map<java.lang.Integer, java.lang.String> names_ = new java.util.HashMap<java.lang.Integer, java.lang.String>();\r\n" +
				"	public java.lang.String getName(java.lang.Integer key) {\r\n" +
				"		return names_.get(key);\r\n" +
				"	}\r\n" +
				"	public java.util.Map<java.lang.Integer, java.lang.String> getNames() {\r\n" +
				"		return Collections.unmodifiableMap(names_);\r\n" +
				"	}\r\n" +
				"	public boolean namesContainsKey(java.lang.Integer key) {\r\n" +
				"		return names_.containsKey(key);\r\n" +
				"	}\r\n" +
				"	public boolean namesContainsValue(java.lang.String value) {\r\n" +
				"		return names_.containsValue(value);\r\n" +
				"	}\r\n" +
				"	public void putName(java.lang.Integer key, java.lang.String value) {\r\n" +
				"		if (key == null) throw new IllegalArgumentException(\"Cannot put null key in name\");\r\n" +
				"		if (value == null) throw new IllegalArgumentException(\"Cannot put null value in name\");\r\n" +
				"		names_.put(key, value);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	public java.lang.String removeName(java.lang.Integer key) {\r\n" +
				"		if (key == null) throw new IllegalArgumentException(\"Cannot remove null key from name\");\r\n" +
				"		java.lang.String result = names_.remove(key);\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"		return result;\r\n" +
				"	}\r\n" +
				"	public void clearNames() {\r\n" +
				"		names_.clear();\r\n" +
				"		getPropertyChangeSupport().firePropertyChange(\"names\", null, names_);\r\n" +
				"	}\r\n" +
				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {\r\n" +
				"		if (o1 == o2) return true;\r\n" +
				"		if (o1 == null || o2 == null) return false;\r\n" +
				"		return o1.equals(o2);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public boolean equals(java.lang.Object obj) {\r\n" +
				"		if (obj == this) return true;\r\n" +
				"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) return false;\r\n" +
				"		FooGen other = (FooGen) obj;\r\n" +
				"		return\r\n" +
				"			checkEquals(other.names_, names_);\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public int hashCode() {\r\n" +
				"		return super.hashCode() +\r\n" +
				"			names_.hashCode();\r\n" +
				"	}\r\n" +
				"	@Override\r\n" +
				"	public java.lang.String toString() {\r\n" +
				"		return getClass().getName() + '[' + paramString() + ']';\r\n" +
				"	}\r\n" +
				"	protected java.lang.String paramString() {\r\n" +
				"		return\r\n" +
				"			\"names=\" + names_;\r\n" +
				"	}\r\n" +
				"}\r\n" +
				"",
				sw.toString());
	}
}
