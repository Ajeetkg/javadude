/*******************************************************************************
 * Copyright (c) 2008 Scott Stanchfield.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Scott Stanchfield - initial API and implementation
 *******************************************************************************/
package com.javadude.annotation.processors;

import java.io.PrintWriter;
import java.util.List;

public class Generator {
	private static final String PADDING = "                                                                                                                        ";
	private Symbols symbols_ = new Symbols();
	private final PrintWriter writer_;
	private final Data data_;

	public Generator(PrintWriter writer, Data data) {
		writer_ = writer;
		data_ = data;
		symbols_ = new Symbols(data.createPropertyMap());
	}
	private String fill(String template) {
		while (true) {
			int start = template.indexOf("${");
			if (start == -1) {
	            break;
            }
			int end = template.indexOf('}', start + 2);
			if (end == -1) {
				throw new RuntimeException("Template has mismatched ${...}");
			}
			String field = template.substring(start + 2, end);
			Object value = symbols_.get(field);
			if (value == null) {
	            throw new RuntimeException("${" + field + "} defined in template not found");
            }
			if (end == template.length()) {
				template = template.substring(0, start) + value;
            } else {
            	template = template.substring(0, start) + value + template.substring(end + 1);
            }
		}
		return template;
	}

	private void g(boolean include, String line) {
		if (include) {
	        g(line);
        }
	}
	private void g(String line) {
		// TODO: check that we have enough room in the PADDING string - increase if necessary
		if (data_.getSpacesForLeadingTabs() > 0) {
			int i = 0;
			while (i < line.length() && line.charAt(i) == '\t') {
				i++;
			}
			if (i > 0) {
				line = PADDING.substring(0, i * data_.getSpacesForLeadingTabs()) + line.substring(i);
			}
		}
       	writer_.println(fill(line));
	}

	public void generate() {
		List<DelegateSpec> delegates = data_.getDelegates();
		List<PropertySpec> properties = data_.getProperties();

		g("// CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR");
		g("// -- DO NOT EDIT  -  THIS CODE WILL BE REGENERATED! --");
		g("package ${packageName};");
		g("");

		// class definition
		g("@javax.annotation.Generated(");
		g("	value = \"com.javadude.annotation.processors.BeanAnnotationProcessor\",");
		g("	date = \"${date}\",");
		g("	comments = \"CODE GENERATED BY JAVADUDE BEAN ANNOTATION PROCESSOR; DO NOT EDIT! THIS CODE WILL BE REGENERATED!\")");

		g("${classAccess}abstract class ${className}Gen ${extendsClause}${cloneableClause} {");
		for (DelegateSpec delegate : delegates) {
			if (delegate.isNeedToDefine()) {
				symbols_.pushScope(delegate.createPropertyMap());
				g("	private ${name} ${accessor};");
				symbols_.popScope();
			}
        }
		g("");
		g("	public ${className}Gen(${superConstructorArgs}) {");
		g("		${superConstructorSuperCall};");

		for (DelegateSpec delegate : delegates) {
			if (delegate.getInstantiateType() != null) {
				symbols_.pushScope(delegate.createPropertyMap());
				g("		${accessor} = new ${instantiateType}();");
				symbols_.popScope();
				// TODO better specification of instance creation - might depend on properties... lazy instantiate?
			}
		}
		g("	}");

		if (data_.isCloneable()) {
			g("	@Override");
			g("	public ${className} clone() {");
			g("		try {");
			g("			return (${className}) super.clone();");
			g("		} catch (CloneNotSupportedException e) {");
			g("			// will not happen");
			g("			return null;");
			g("		}");
			g("	}");
		}

		// If any bound properties exist, add PropertyChangeSupport and delegate methods for it
		if (data_.isAtLeastOneBound()) {
			g("	private java.beans.PropertyChangeSupport propertyChangeSupport_ = new java.beans.PropertyChangeSupport(this);");
			g("	protected java.beans.PropertyChangeSupport getPropertyChangeSupport() {");
			g("		return propertyChangeSupport_;");
			g("	}");
			g("	public void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {");
			g("		getPropertyChangeSupport().addPropertyChangeListener(listener);");
			g("	}");
			g("	public void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {");
			g("		getPropertyChangeSupport().addPropertyChangeListener(propertyName, listener);");
			g("	}");
			g("	public void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {");
			g("		getPropertyChangeSupport().removePropertyChangeListener(listener);");
			g("	}");
			g("	public void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {");
			g("		getPropertyChangeSupport().removePropertyChangeListener(propertyName, listener);");
			g("	}");
		}

		for (PropertySpec property : properties) {
			symbols_.pushScope(property.createPropertyMap());
			boolean r = property.isReadable();
			boolean w = property.isWriteable();
			boolean notNull = property.isNotNull();
			boolean bound = property.isBound();

			if (property.getKind().isSimple()) {
				g(				"	private ${extraFieldKeywords}${type} ${name}_;");
				g(r,			"	${readerAccess}${extraMethodKeywords}${type} ${isOrGet}${upperName}() {");
				g(r,			"		return ${name}_;");
				g(r,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void set${upperName}(${type} value)  {");
				g(w && notNull,	"		if (value == null) throw new IllegalArgumentException(\"${name} cannot be null\");");
				g(w && bound,	"		${type} oldValue = ${name}_;");
				g(w,			"		${name}_ = value;");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${name}\", oldValue, value);");
				g(w,			"	}");


			} else if (property.getKind().isList()) {
			    g(				"	private ${extraFieldKeywords}final java.util.List<${type}> ${pluralName}_ = new java.util.ArrayList<${type}>();");
				g(r,			"	${readerAccess}${extraMethodKeywords}${type} ${isOrGet}${upperName}(int i) {");
				g(r,			"		return ${pluralName}_.get(i);");
				g(r,			"	}");
				g(r,			"	${readerAccess}${extraMethodKeywords}java.util.List<${type}> get${upperPluralName}() {");
				g(r,			"		return ${unmodPrefix}${pluralName}_${unmodSuffix};");
				g(r,			"	}");
				g(r,			"	${readerAccess}${extraMethodKeywords}boolean ${pluralName}Contains(${type} value) {");
				g(r,			"		return ${pluralName}_.contains(value);");
				g(r,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void add${upperName}(${type} value) {");
				g(w,			"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to ${name}\");");
				g(w,			"		${pluralName}_.add(value);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}boolean remove${upperName}(${type} value) {");
				g(w,			"		if (value == null) throw new IllegalArgumentException(\"Cannot remove null from ${name}\");");
				g(w,			"		boolean result = ${pluralName}_.remove(value);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"		return result;");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}${type} remove${upperName}(int i) {");
				g(w,			"		${type} result = ${pluralName}_.remove(i);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"		return result;");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void add${upperName}(int i, ${type} value) {");
				g(w,			"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to ${name}\");");
				g(w,			"		${pluralName}_.add(i, value);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void clear${upperPluralName}() {");
		    	g(w,			"		${pluralName}_.clear();");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"	}");

			} else if (property.getKind().isSet()) {
			    g(				"	private ${extraFieldKeywords}final java.util.Set<${type}> ${pluralName}_ = new java.util.HashSet<${type}>();");
				g(r,			"	${readerAccess}${extraMethodKeywords}java.util.Set<${type}> get${upperPluralName}() {");
				g(r,			"		return ${unmodPrefix}${pluralName}_${unmodSuffix};");
				g(r,			"	}");
				g(r,			"	${readerAccess}${extraMethodKeywords}boolean ${pluralName}Contains(${type} value) {");
				g(r,			"		return ${pluralName}_.contains(value);");
				g(r,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void add${upperName}(${type} value) {");
				g(w,			"		if (value == null) throw new IllegalArgumentException(\"Cannot add null to ${name}\");");
				g(w,			"		${pluralName}_.add(value);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}boolean remove${upperName}(${type} value) {");
				g(w,			"		if (value == null) throw new IllegalArgumentException(\"Cannot remove null from ${name}\");");
				g(w,			"		boolean result = ${pluralName}_.remove(value);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"		return result;");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void clear${upperPluralName}() {");
				g(w,			"		${pluralName}_.clear();");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"	}");

			} else { // it's a MAP property
				g(				"	private ${extraFieldKeywords}final java.util.Map<${keyType}, ${type}> ${pluralName}_ = new java.util.HashMap<${keyType}, ${type}>();");
				g(r,			"	${readerAccess}${extraMethodKeywords}${type} get${upperName}(${keyType} key) {");
				g(r,			"		return ${pluralName}_.get(key);");
				g(r,			"	}");
				g(r,			"	${readerAccess}${extraMethodKeywords}java.util.Map<${keyType}, ${type}> get${upperPluralName}() {");
				g(r,			"		return ${unmodPrefix}${pluralName}_${unmodSuffix};");
				g(r,			"	}");
				g(r,			"	${readerAccess}${extraMethodKeywords}boolean ${pluralName}ContainsKey(${keyType} key) {");
				g(r,			"		return ${pluralName}_.containsKey(key);");
				g(r,			"	}");
				g(r,			"	${readerAccess}${extraMethodKeywords}boolean ${pluralName}ContainsValue(${type} value) {");
				g(r,			"		return ${pluralName}_.containsValue(value);");
				g(r,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void put${upperName}(${keyType} key, ${type} value) {");
				g(w,			"		if (key == null) throw new IllegalArgumentException(\"Cannot put null key in ${name}\");");
				g(w,			"		if (value == null) throw new IllegalArgumentException(\"Cannot put null value in ${name}\");");
				g(w,			"		${pluralName}_.put(key, value);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}${type} remove${upperName}(${keyType} key) {");
				g(w,			"		if (key == null) throw new IllegalArgumentException(\"Cannot remove null key from ${name}\");");
				g(w,			"		${type} result = ${pluralName}_.remove(key);");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"		return result;");
				g(w,			"	}");
				g(w,			"	${writerAccess}${extraMethodKeywords}void clear${upperPluralName}() {");
				g(w,			"		${pluralName}_.clear();");
				g(w && bound,	"		getPropertyChangeSupport().firePropertyChange(\"${pluralName}\", null, ${pluralName}_);");
				g(w,			"	}");
			}

			symbols_.popScope();

		} // end for each property

		// define default methods
		for (Method defaultMethod : data_.getDefaultMethods()) {
			symbols_.pushScope(defaultMethod.createPropertyMap());
			g(								"${access}${qualifiers}${returnType} ${name}(${argDecls})${throwsClause} ${symbolAfterDecl}");
			g(!defaultMethod.isAbstract(),	"	${returnOrNot}${name}(${args});");
			g(!defaultMethod.isAbstract(),	"}");
			symbols_.popScope();
		}

		// define delegate methods
		for (DelegateSpec delegate : data_.getDelegates()) {
			symbols_.pushScope(delegate.createPropertyMap());
			for (Method method : delegate.getMethods()) {
				symbols_.pushScope(method.createPropertyMap());
				g(delegate.isOverriding(),	"	@Override");
				g(							"	public ${returnType} ${name}(${argDecls})${throwsClause} {");
				g(							"		${returnOrNot}${accessor}.${name}(${args});"); // accessor is from DelegateSpec
				g(							"	}");
				symbols_.popScope();
            }
			symbols_.popScope();
        }

		// define null object implementations
		for (Listener nullObject : data_.getNullImplementations()) {
			for (Method method : nullObject.getMethods()) {
				symbols_.pushScope(method.createPropertyMap());
				g(nullObject.isOverriding(),	"	@Override");
				g(								"	public ${returnType} ${name}(${argDecls})${throwsClause} {");
				g(								"		${nullBody}");
				g(							"	}");
				symbols_.popScope();
			}
		}

		// Define observer management and fire methods
		//	TODO - what if the methods are declared to throw exceptions (like PropertyVetoException)?
		for (Listener observer : data_.getListeners()) {
			symbols_.pushScope(observer.createPropertyMap());
    	    g("	private java.util.List<${name}> ${lowerName}s_ = new java.util.ArrayList<${name}>();");
    	    g("	public void add${nameWithoutPackage}(${name} listener) {");
    	    g("		synchronized(${lowerName}s_) {");
    	    g("			${lowerName}s_.add(listener);");
    	    g("		}");
    	    g("	}");
    	    g("	public void remove${nameWithoutPackage}(${name} listener) {");
    	    g("		synchronized(${lowerName}s_) {");
    	    g("			${lowerName}s_.remove(listener);");
    	    g("		}");
    	    g("	}");
    	    for (Method method : observer.getMethods()) {
        	    symbols_.pushScope(method.createPropertyMap());
        	    g("	protected void fire${upperName}(${argDecls}) {");
        	    g("		java.util.List<${up:name}> targets = null;");
        	    g("		synchronized(${up:lowerName}s_) {");
        	    g("			targets = new java.util.ArrayList<${up:name}>(${up:lowerName}s_);");
        	    g("		}");
        	    g("		for (${up:name} listener : targets) {");
        	    g("			listener.${name}(${args});");
        	    g("		}");
        	    g("	}");
        	    symbols_.popScope();
    	    }
    	    symbols_.popScope();
		}

		// Define simple equals() and hashCode() methods
		if (data_.isDefineSimpleEqualsAndHashCode()) {
			boolean checkSuper = data_.isEqualsShouldCheckSuperEquals();
			g(				"	protected boolean checkEquals(java.lang.Object o1, java.lang.Object o2) {");
			g(				"		if (o1 == o2) {");
			g(				"			return true;");
			g(				"		}");
			g(				"		if (o1 == null || o2 == null) {");
			g(				"			return false;");
			g(				"		}");
			g(				"		return o1.equals(o2);");
			g(				"	}");

			g(				"	@Override");
			g(				"	public boolean equals(java.lang.Object obj) {");
			g(				"		if (obj == this) {");
			g(				"			return true;");
			g(				"		}");

			g(checkSuper,	"		if (obj == null || obj.getClass() != getClass() || !super.equals(obj)) {");
			g(!checkSuper,	"		if (obj == null || obj.getClass() != getClass()) {");
			g(				"			return false;");
			g(				"		}");
			g(				"		${className}Gen other = (${className}Gen) obj;");
			g(				"		return");
			int last = data_.getProperties().size();
			int current = 0;
			String op = " &&";
			for (PropertySpec property : properties) {
	            symbols_.pushScope(property.createPropertyMap());
	            current++;
	            if (current == last) {
	            	op = ";";
	            }
	            boolean simple = property.getKind().isSimple();
	            boolean primitive = property.isPrimitive();
	            g(primitive,				"			other.${property.name}_ == ${property.name}_" + op);
	            g(!simple,					"			checkEquals(other.${property.pluralName}_, ${property.pluralName}_)" + op);
	            g(!primitive && !simple,	"			checkEquals(other.${property.name}_, ${property.name}_)" + op);
	            symbols_.popScope();
            }

			// TODO: better hashcode algorithm
			g("	@Override");
			g("	public int hashCode() {");
			g("		return super.hashCode() +");
			last = data_.getProperties().size();
			current = 0;
			op = " +";
			for (PropertySpec property : properties) {
				symbols_.pushScope(property.createPropertyMap());
				current++;
				if (current == last) {
					op = ";";
				}
				if (property.getKind().isSimple()) {
	                g("			${property.intConversion}${op}" + op);
                } else {
	                g("			${property.pluralName}_.hashCode()${op}" + op);
                }
				symbols_.popScope();
			}
			g("	}");
		}

		g("	}"); // close off the class
	}
}

//	##
//	## Define a nice default toString method
//	##
//	    @Override
//	    public java.lang.String toString() {
//	        return getClass().getName() + '[' + paramString() + ']';
//	    }
//	#if (${data.isParamStringOverridden()})
//	    @Override
//	#end
//	    protected java.lang.String paramString() {
//	#if (${data.properties.isEmpty()})
//	        return "";
//	#else
//	        return
//	#set ($last = ${data.properties.size()})
//	#set ($current = 0)
//	#set ($op = " +")
//	#set ($comma = "")
//	#foreach ($property in ${data.properties})
//	#set ($current = $current + 1)
//	#if ($current == $last)
//	#set ($op = ";")
//	#end
//	#if (!${property.omitFromToString})
//	#if (${property.kind.isSimple()})
//	               "${comma}${property.name}=" + ${property.name}_${op}
//	#else
//	               "${comma}${property.pluralName}=" + ${property.pluralName}_${op}
//	#end
//	#set ($comma = ",")
//	#end
//	#end
//	#end
//	    }
//	#if (${data.isCreatePropertyMap()})
//	    public java.util.Map<java.lang.String, java.lang.Object> createPropertyMap() {
//	                    java.util.Map<java.lang.String, java.lang.Object> map = new java.util.HashMap<java.lang.String, java.lang.Object>();
//	#foreach ($property in ${data.properties})
//	#if (${property.isReadable()})
//	#if (${property.kind.isSimple()})
//	                    map.put("${property.name}", ${property.isGet()}${property.upperName}());
//	        #else
//	                    map.put("${property.pluralName}", ${property.isGet()}${property.upperPluralName}());
//	#end
//	#end
//	#end
//	        return map;
//	    }
//	#end
//	}

//}
